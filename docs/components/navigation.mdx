---
title: 'Navigation Components'
description: 'Master Menu, Tabs, Breadcrumb, and navigation components'
---

## Navigation Components

Navigation components help users move through your application and understand their current location. They provide intuitive ways to organize and access different sections of your TUI application.

<CardGroup cols={3}>
  <Card title="Menu" icon="menu">
    Interactive menu systems
  </Card>
  <Card title="Tabs" icon="tab">
    Tabbed interface navigation
  </Card>
  <Card title="Breadcrumb" icon="chevron-right">
    Hierarchical navigation paths
  </Card>
</CardGroup>

## Menu Component

The `Menu` component provides flexible menu systems with nested items, keyboard navigation, and customizable styling.

### Basic Menu Usage

<CodeGroup>

```typescript Simple Menu
import { useTerminal, Box, Menu } from '@tui-kit-ai/core';

const { screen } = useTerminal();

const container = new Box({
  parent: screen,
  top: 'center',
  left: 'center',
  width: 60,
  height: 20,
  border: { type: 'line' },
  label: ' Menu Examples '
});

// Basic vertical menu
const mainMenu = new Menu({
  parent: container.el,
  top: 2,
  left: 2,
  width: 25,
  items: [
    { label: 'üìÅ New File', action: 'file:new' },
    { label: 'üìÇ Open File', action: 'file:open' },
    { label: 'üíæ Save File', action: 'file:save' },
    { separator: true },
    { label: '‚öôÔ∏è Settings', action: 'settings' },
    { label: '‚ùì Help', action: 'help' },
    { separator: true },
    { label: 'üö™ Exit', action: 'exit', style: { fg: 'red' } }
  ],
  onSelect: (item) => {
    console.log('Menu item selected:', item.action);
    handleMenuAction(item.action);
  }
});

function handleMenuAction(action: string) {
  switch (action) {
    case 'file:new':
      createNewFile();
      break;
    case 'file:open':
      openFileDialog();
      break;
    case 'settings':
      openSettings();
      break;
    case 'exit':
      process.exit(0);
      break;
  }
}
```

```typescript Nested Menu
const nestedMenu = new Menu({
  parent: container.el,
  top: 2,
  left: 30,
  width: 25,
  items: [
    {
      label: 'üìÅ File',
      submenu: [
        { label: 'üìÑ New', action: 'file:new' },
        { label: 'üìÇ Open', action: 'file:open' },
        { label: 'üíæ Save', action: 'file:save' },
        { separator: true },
        {
          label: 'üì§ Export',
          submenu: [
            { label: 'üìã Copy to Clipboard', action: 'export:clipboard' },
            { label: 'üìÅ Save as JSON', action: 'export:json' },
            { label: 'üìä Save as CSV', action: 'export:csv' }
          ]
        }
      ]
    },
    {
      label: '‚úèÔ∏è Edit',
      submenu: [
        { label: '‚Ü∂ Undo', action: 'edit:undo', shortcut: 'Ctrl+Z' },
        { label: '‚Ü∑ Redo', action: 'edit:redo', shortcut: 'Ctrl+Y' },
        { separator: true },
        { label: '‚úÇÔ∏è Cut', action: 'edit:cut', shortcut: 'Ctrl+X' },
        { label: 'üìã Copy', action: 'edit:copy', shortcut: 'Ctrl+C' },
        { label: 'üìå Paste', action: 'edit:paste', shortcut: 'Ctrl+V' }
      ]
    },
    {
      label: 'ü§ñ AI',
      submenu: [
        { label: 'üí¨ Start Chat', action: 'ai:chat' },
        { label: '‚ú® Complete Code', action: 'ai:complete' },
        { label: 'üîç Analyze Code', action: 'ai:analyze' },
        { separator: true },
        {
          label: '‚öôÔ∏è Model Settings',
          submenu: [
            { label: 'üß† GPT-4', action: 'ai:model:gpt4' },
            { label: 'üé≠ Claude', action: 'ai:model:claude' },
            { label: 'üè† Local (Ollama)', action: 'ai:model:ollama' }
          ]
        }
      ]
    }
  ],
  showShortcuts: true,
  onSelect: (item) => {
    console.log('Selected:', item.action);
  }
});
```

```typescript Dynamic Menu
class DynamicMenu extends Menu {
  private recentFiles: string[] = [];
  private bookmarks: string[] = [];
  
  constructor(props: MenuProps) {
    super(props);
    this.loadUserData();
    this.buildMenu();
  }
  
  private async loadUserData() {
    // Load recent files and bookmarks
    this.recentFiles = await this.loadRecentFiles();
    this.bookmarks = await this.loadBookmarks();
    this.updateMenu();
  }
  
  addRecentFile(filePath: string) {
    // Add to recent files (max 10)
    this.recentFiles.unshift(filePath);
    this.recentFiles = this.recentFiles.slice(0, 10);
    this.updateMenu();
  }
  
  private updateMenu() {
    const menuItems = [
      { label: 'üìÑ New File', action: 'file:new' },
      { label: 'üìÇ Open File', action: 'file:open' },
      { separator: true },
      
      // Recent files submenu
      {
        label: 'üïí Recent Files',
        disabled: this.recentFiles.length === 0,
        submenu: this.recentFiles.map(file => ({
          label: `üìÑ ${this.getFileName(file)}`,
          action: `file:open:${file}`,
          tooltip: file
        }))
      },
      
      // Bookmarks submenu
      {
        label: '‚≠ê Bookmarks',
        disabled: this.bookmarks.length === 0,
        submenu: this.bookmarks.map(bookmark => ({
          label: `üìÅ ${this.getFileName(bookmark)}`,
          action: `file:open:${bookmark}`
        }))
      },
      
      { separator: true },
      { label: '‚öôÔ∏è Settings', action: 'settings' },
      { label: 'üö™ Exit', action: 'exit' }
    ];
    
    this.setItems(menuItems);
  }
  
  private getFileName(path: string): string {
    return path.split('/').pop() || path;
  }
}
```

</CodeGroup>

### Menu Properties

<AccordionGroup>
  <Accordion title="Basic Properties">
    ```typescript
    interface MenuProps extends BaseProps {
      items: MenuItem[];
      orientation?: 'vertical' | 'horizontal';
      showShortcuts?: boolean;
      showIcons?: boolean;
      autoClose?: boolean;        // Close after selection
      closeOnClickOutside?: boolean;
      
      // Selection
      selected?: number;          // Initially selected item
      multiSelect?: boolean;      // Allow multiple selections
      
      // Events
      onSelect?: (item: MenuItem, index: number) => void;
      onHover?: (item: MenuItem, index: number) => void;
      onOpen?: (item: MenuItem) => void;
      onClose?: (item: MenuItem) => void;
    }
    
    interface MenuItem {
      label: string;
      action?: string;
      shortcut?: string;
      icon?: string;
      disabled?: boolean;
      separator?: boolean;
      submenu?: MenuItem[];
      style?: StyleConfig;
      tooltip?: string;
    }
    ```
  </Accordion>
  
  <Accordion title="Advanced Features">
    ```typescript
    // Context menu
    const contextMenu = new Menu({
      parent: screen,
      items: [
        { label: '‚úÇÔ∏è Cut', action: 'cut' },
        { label: 'üìã Copy', action: 'copy' },
        { label: 'üìå Paste', action: 'paste' },
        { separator: true },
        { label: 'üóëÔ∏è Delete', action: 'delete', style: { fg: 'red' } }
      ],
      contextMenu: true,  // Behaves as context menu
      onSelect: (item) => {
        console.log('Context action:', item.action);
        contextMenu.hide();
      }
    });
    
    // Show context menu on right-click
    someComponent.on('rightclick', (x, y) => {
      contextMenu.showAt(x, y);
    });
    
    // Menu with search
    const searchableMenu = new Menu({
      parent: container.el,
      items: largeItemList,
      searchable: true,
      searchPlaceholder: 'Search menu items...',
      onSearch: (query) => {
        const filtered = largeItemList.filter(item =>
          item.label.toLowerCase().includes(query.toLowerCase())
        );
        searchableMenu.setItems(filtered);
      }
    });
    ```
  </Accordion>
  
  <Accordion title="Menu Bar">
    ```typescript
    class MenuBar {
      private container: Box;
      private menus: Map<string, Menu> = new Map();
      private currentMenu: string | null = null;
      
      constructor(parent: any) {
        this.container = new Box({
          parent,
          top: 0,
          left: 0,
          right: 0,
          height: 1,
          style: { bg: 'blue', fg: 'white' }
        });
        
        this.createMenus();
        this.setupEventHandlers();
      }
      
      private createMenus() {
        const menuData = {
          'File': [
            { label: 'New', action: 'file:new', shortcut: 'Ctrl+N' },
            { label: 'Open', action: 'file:open', shortcut: 'Ctrl+O' },
            { label: 'Save', action: 'file:save', shortcut: 'Ctrl+S' }
          ],
          'Edit': [
            { label: 'Undo', action: 'edit:undo', shortcut: 'Ctrl+Z' },
            { label: 'Redo', action: 'edit:redo', shortcut: 'Ctrl+Y' }
          ],
          'View': [
            { label: 'Zoom In', action: 'view:zoomin', shortcut: 'Ctrl++' },
            { label: 'Zoom Out', action: 'view:zoomout', shortcut: 'Ctrl+-' }
          ]
        };
        
        let xPos = 1;
        Object.entries(menuData).forEach(([title, items]) => {
          // Menu title
          const titleLabel = new Text({
            parent: this.container.el,
            top: 0,
            left: xPos,
            content: ` ${title} `,
            clickable: true,
            style: { bg: 'blue', fg: 'white' }
          });
          
          // Dropdown menu
          const menu = new Menu({
            parent: this.container.parent,
            top: 1,
            left: xPos,
            items,
            hidden: true,
            onSelect: (item) => {
              this.handleMenuAction(item.action);
              this.hideAllMenus();
            }
          });
          
          this.menus.set(title, menu);
          
          // Click handler
          titleLabel.on('click', () => {
            this.toggleMenu(title);
          });
          
          xPos += title.length + 3;
        });
      }
      
      private toggleMenu(menuTitle: string) {
        if (this.currentMenu === menuTitle) {
          this.hideAllMenus();
        } else {
          this.hideAllMenus();
          this.showMenu(menuTitle);
        }
      }
      
      private showMenu(menuTitle: string) {
        const menu = this.menus.get(menuTitle);
        if (menu) {
          menu.show();
          this.currentMenu = menuTitle;
        }
      }
      
      private hideAllMenus() {
        this.menus.forEach(menu => menu.hide());
        this.currentMenu = null;
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Tabs Component

The `Tabs` component provides tabbed interfaces for organizing content into switchable panels.

### Basic Tabs Usage

<CodeGroup>

```typescript Simple Tabs
import { Tabs } from '@tui-kit-ai/core';

const simpleTabs = new Tabs({
  parent: container.el,
  top: 2,
  left: 2,
  right: 2,
  height: 15,
  tabs: [
    {
      id: 'chat',
      label: 'üí¨ Chat',
      content: 'Chat with AI assistant...'
    },
    {
      id: 'settings',
      label: '‚öôÔ∏è Settings',
      content: 'Application settings...'
    },
    {
      id: 'help',
      label: '‚ùì Help',
      content: 'Help documentation...'
    }
  ],
  activeTab: 'chat',
  onTabChange: (tabId, tab) => {
    console.log('Switched to tab:', tabId);
  }
});
```

```typescript Advanced Tabs
class AdvancedTabs extends Tabs {
  private tabContents: Map<string, any> = new Map();
  private unsavedChanges: Set<string> = new Set();
  
  constructor(props: TabsProps) {
    super(props);
    this.setupAdvancedFeatures();
  }
  
  addTab(tab: TabConfig) {
    super.addTab(tab);
    
    // Create content component
    const content = this.createTabContent(tab);
    this.tabContents.set(tab.id, content);
    
    // Track changes
    content.on('change', () => {
      this.markTabUnsaved(tab.id);
    });
  }
  
  closeTab(tabId: string) {
    if (this.unsavedChanges.has(tabId)) {
      this.showUnsavedChangesDialog(tabId);
    } else {
      this.removeTab(tabId);
    }
  }
  
  private markTabUnsaved(tabId: string) {
    this.unsavedChanges.add(tabId);
    this.updateTabLabel(tabId, this.getTabLabel(tabId) + ' ‚Ä¢');
  }
  
  private markTabSaved(tabId: string) {
    this.unsavedChanges.delete(tabId);
    const label = this.getTabLabel(tabId).replace(' ‚Ä¢', '');
    this.updateTabLabel(tabId, label);
  }
  
  async saveTab(tabId: string) {
    const content = this.tabContents.get(tabId);
    if (content && content.save) {
      await content.save();
      this.markTabSaved(tabId);
    }
  }
  
  private showUnsavedChangesDialog(tabId: string) {
    const dialog = new Modal({
      parent: this.parent,
      title: 'Unsaved Changes',
      content: 'You have unsaved changes. Do you want to save before closing?',
      buttons: [
        {
          label: 'Save & Close',
          variant: 'primary',
          action: async () => {
            await this.saveTab(tabId);
            this.removeTab(tabId);
            dialog.close();
          }
        },
        {
          label: 'Close Without Saving',
          variant: 'danger',
          action: () => {
            this.removeTab(tabId);
            dialog.close();
          }
        },
        {
          label: 'Cancel',
          variant: 'secondary',
          action: () => {
            dialog.close();
          }
        }
      ]
    });
    
    dialog.show();
  }
}
```

```typescript Tab Management System
class TabManager {
  private tabs: AdvancedTabs;
  private maxTabs = 10;
  private tabHistory: string[] = [];
  
  constructor(parent: any) {
    this.tabs = new AdvancedTabs({
      parent,
      closable: true,
      reorderable: true,
      onTabChange: (tabId) => {
        this.addToHistory(tabId);
      },
      onTabClose: (tabId) => {
        this.removeFromHistory(tabId);
      },
      onTabReorder: (fromIndex, toIndex) => {
        this.handleTabReorder(fromIndex, toIndex);
      }
    });
    
    this.setupKeyboardShortcuts();
  }
  
  openFile(filePath: string) {
    const tabId = this.generateTabId(filePath);
    
    // Check if tab already exists
    if (this.tabs.hasTab(tabId)) {
      this.tabs.setActiveTab(tabId);
      return;
    }
    
    // Check tab limit
    if (this.tabs.getTabCount() >= this.maxTabs) {
      this.closeLeastRecentlyUsedTab();
    }
    
    // Create new tab
    const fileName = filePath.split('/').pop() || filePath;
    this.tabs.addTab({
      id: tabId,
      label: `üìÑ ${fileName}`,
      closable: true,
      tooltip: filePath
    });
    
    this.loadFileContent(tabId, filePath);
    this.tabs.setActiveTab(tabId);
  }
  
  private setupKeyboardShortcuts() {
    // Ctrl+T: New tab
    this.tabs.key(['C-t'], () => {
      this.createNewTab();
    });
    
    // Ctrl+W: Close current tab
    this.tabs.key(['C-w'], () => {
      const currentTab = this.tabs.getActiveTab();
      if (currentTab) {
        this.tabs.closeTab(currentTab.id);
      }
    });
    
    // Ctrl+Tab: Next tab
    this.tabs.key(['C-tab'], () => {
      this.nextTab();
    });
    
    // Ctrl+Shift+Tab: Previous tab
    this.tabs.key(['C-S-tab'], () => {
      this.previousTab();
    });
    
    // Ctrl+1-9: Switch to tab by index
    for (let i = 1; i <= 9; i++) {
      this.tabs.key([`C-${i}`], () => {
        this.switchToTabByIndex(i - 1);
      });
    }
  }
  
  private closeLeastRecentlyUsedTab() {
    // Find least recently used tab
    const allTabs = this.tabs.getTabs();
    let lruTab = null;
    let oldestTime = Infinity;
    
    for (const tab of allTabs) {
      const lastUsed = this.getTabLastUsedTime(tab.id);
      if (lastUsed < oldestTime) {
        oldestTime = lastUsed;
        lruTab = tab;
      }
    }
    
    if (lruTab) {
      this.tabs.closeTab(lruTab.id);
    }
  }
  
  nextTab() {
    const currentIndex = this.tabs.getActiveTabIndex();
    const tabCount = this.tabs.getTabCount();
    const nextIndex = (currentIndex + 1) % tabCount;
    this.switchToTabByIndex(nextIndex);
  }
  
  previousTab() {
    const currentIndex = this.tabs.getActiveTabIndex();
    const tabCount = this.tabs.getTabCount();
    const prevIndex = (currentIndex - 1 + tabCount) % tabCount;
    this.switchToTabByIndex(prevIndex);
  }
}
```

</CodeGroup>

### Tabs Properties

```typescript
interface TabsProps extends BaseProps {
  tabs: TabConfig[];
  activeTab?: string;         // Initially active tab ID
  position?: 'top' | 'bottom' | 'left' | 'right';
  closable?: boolean;         // Show close buttons
  reorderable?: boolean;      // Allow drag-and-drop reordering
  scrollable?: boolean;       // Scroll tabs if too many
  
  // Styling
  tabStyle?: StyleConfig;
  activeTabStyle?: StyleConfig;
  contentStyle?: StyleConfig;
  
  // Events
  onTabChange?: (tabId: string, tab: TabConfig) => void;
  onTabClose?: (tabId: string, tab: TabConfig) => void;
  onTabReorder?: (fromIndex: number, toIndex: number) => void;
  onTabAdd?: (tab: TabConfig) => void;
}

interface TabConfig {
  id: string;
  label: string;
  content?: string | Component;
  icon?: string;
  closable?: boolean;
  disabled?: boolean;
  tooltip?: string;
  badge?: string | number;
  style?: StyleConfig;
}
```

## Breadcrumb Component

The `Breadcrumb` component shows hierarchical navigation paths and allows users to navigate back to parent levels.

<CodeGroup>

```typescript Basic Breadcrumb
import { Breadcrumb } from '@tui-kit-ai/core';

const pathBreadcrumb = new Breadcrumb({
  parent: container.el,
  top: 2,
  left: 2,
  right: 2,
  height: 1,
  items: [
    { label: 'Home', path: '/' },
    { label: 'Projects', path: '/projects' },
    { label: 'AI Assistant', path: '/projects/ai-assistant' },
    { label: 'Components', path: '/projects/ai-assistant/components' }
  ],
  separator: ' > ',
  onNavigate: (item, index) => {
    console.log('Navigate to:', item.path);
    navigateToPath(item.path);
  }
});
```

```typescript Dynamic Breadcrumb
class DynamicBreadcrumb extends Breadcrumb {
  private currentPath: string[] = [];
  
  constructor(props: BreadcrumbProps) {
    super(props);
  }
  
  navigateTo(path: string) {
    this.currentPath = path.split('/').filter(segment => segment);
    this.updateBreadcrumb();
  }
  
  navigateUp(levels: number = 1) {
    this.currentPath = this.currentPath.slice(0, -levels);
    this.updateBreadcrumb();
  }
  
  private updateBreadcrumb() {
    const items = [
      { label: 'üè† Home', path: '/' }
    ];
    
    let currentPath = '';
    this.currentPath.forEach((segment, index) => {
      currentPath += '/' + segment;
      items.push({
        label: this.formatSegment(segment),
        path: currentPath
      });
    });
    
    this.setItems(items);
  }
  
  private formatSegment(segment: string): string {
    // Convert kebab-case to Title Case
    return segment
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
}

// Usage
const breadcrumb = new DynamicBreadcrumb({
  parent: container.el,
  onNavigate: (item) => {
    router.navigateTo(item.path);
  }
});

// Update breadcrumb based on current route
breadcrumb.navigateTo('/projects/ai-assistant/components/navigation');
```

```typescript File System Breadcrumb
class FileSystemBreadcrumb extends Breadcrumb {
  private fileSystem: FileSystemAPI;
  
  constructor(parent: any, fileSystem: FileSystemAPI) {
    super({
      parent,
      separator: ' / ',
      showIcons: true,
      onNavigate: (item) => {
        this.navigateToDirectory(item.path);
      }
    });
    
    this.fileSystem = fileSystem;
  }
  
  async setCurrentDirectory(dirPath: string) {
    const pathSegments = dirPath.split('/').filter(Boolean);
    const items: BreadcrumbItem[] = [
      { label: 'üíª Root', path: '/', icon: 'üíª' }
    ];
    
    let currentPath = '';
    for (const segment of pathSegments) {
      currentPath += '/' + segment;
      
      try {
        const stat = await this.fileSystem.stat(currentPath);
        const icon = stat.isDirectory() ? 'üìÅ' : 'üìÑ';
        
        items.push({
          label: segment,
          path: currentPath,
          icon
        });
      } catch (error) {
        // Handle inaccessible directories
        items.push({
          label: segment,
          path: currentPath,
          icon: '‚ùå',
          disabled: true,
          tooltip: 'Directory not accessible'
        });
      }
    }
    
    this.setItems(items);
  }
  
  private async navigateToDirectory(path: string) {
    try {
      const contents = await this.fileSystem.readdir(path);
      this.emit('directoryChanged', path, contents);
    } catch (error) {
      this.emit('navigationError', error);
    }
  }
}
```

</CodeGroup>

### Breadcrumb Properties

```typescript
interface BreadcrumbProps extends BaseProps {
  items: BreadcrumbItem[];
  separator?: string;         // Separator between items (default: ' > ')
  showIcons?: boolean;        // Show icons in breadcrumb items
  maxItems?: number;         // Maximum items to show (with ellipsis)
  
  // Styling
  itemStyle?: StyleConfig;
  separatorStyle?: StyleConfig;
  activeItemStyle?: StyleConfig;
  
  // Events
  onNavigate?: (item: BreadcrumbItem, index: number) => void;
  onItemHover?: (item: BreadcrumbItem, index: number) => void;
}

interface BreadcrumbItem {
  label: string;
  path: string;
  icon?: string;
  disabled?: boolean;
  tooltip?: string;
  metadata?: any;           // Additional data
}
```

## Navigation Best Practices

### 1. Menu Organization

```typescript
class MenuOrganizer {
  static organizeByFrequency(items: MenuItem[], usage: Map<string, number>): MenuItem[] {
    return items.sort((a, b) => {
      const usageA = usage.get(a.action) || 0;
      const usageB = usage.get(b.action) || 0;
      return usageB - usageA; // Most used first
    });
  }
  
  static groupByCategory(items: MenuItem[]): MenuItem[] {
    const groups = new Map<string, MenuItem[]>();
    
    items.forEach(item => {
      const category = item.action?.split(':')[0] || 'other';
      if (!groups.has(category)) {
        groups.set(category, []);
      }
      groups.get(category)!.push(item);
    });
    
    const result: MenuItem[] = [];
    groups.forEach((groupItems, category) => {
      if (result.length > 0) {
        result.push({ separator: true });
      }
      result.push(...groupItems);
    });
    
    return result;
  }
}
```

### 2. Keyboard Navigation

```typescript
class KeyboardNavigationManager {
  private components: Map<string, NavigationComponent> = new Map();
  private currentFocus: string | null = null;
  
  registerComponent(id: string, component: NavigationComponent) {
    this.components.set(id, component);
    
    component.on('focus', () => {
      this.currentFocus = id;
    });
    
    component.on('navigate', (direction: NavigationDirection) => {
      this.navigate(direction);
    });
  }
  
  navigate(direction: NavigationDirection) {
    const current = this.components.get(this.currentFocus);
    if (!current) return;
    
    const next = this.findNextComponent(current, direction);
    if (next) {
      next.focus();
    }
  }
  
  private findNextComponent(
    current: NavigationComponent,
    direction: NavigationDirection
  ): NavigationComponent | null {
    // Implementation for finding next focusable component
    // based on spatial relationships
    return null;
  }
}
```

### 3. State Management

```typescript
class NavigationStateManager {
  private history: string[] = [];
  private currentIndex = -1;
  private maxHistorySize = 50;
  
  navigate(path: string) {
    // Remove forward history if navigating from middle
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    
    // Add new path
    this.history.push(path);
    
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
    
    this.emit('navigate', path);
  }
  
  back(): string | null {
    if (this.canGoBack()) {
      this.currentIndex--;
      const path = this.history[this.currentIndex];
      this.emit('navigate', path);
      return path;
    }
    return null;
  }
  
  forward(): string | null {
    if (this.canGoForward()) {
      this.currentIndex++;
      const path = this.history[this.currentIndex];
      this.emit('navigate', path);
      return path;
    }
    return null;
  }
  
  canGoBack(): boolean {
    return this.currentIndex > 0;
  }
  
  canGoForward(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Container Components"
    icon="square"
    href="/components/containers"
  >
    Learn about Modal, Scrollable, and container components
  </Card>
  <Card
    title="AI Integration"
    icon="brain"
    href="/ai/overview"
  >
    Combine navigation with AI-powered applications
  </Card>
  <Card
    title="Complete Examples"
    icon="code"
    href="/examples/overview"
  >
    See navigation components in real applications
  </Card>
  <Card
    title="Layout Components"
    icon="grid-2"
    href="/components/layout"
  >
    Review layout components for structure
  </Card>
</CardGroup>